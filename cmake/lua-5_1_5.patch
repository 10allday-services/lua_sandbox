diff -Naur /work/lua-5.1.5/CMakeLists.txt lua-5_1_5/CMakeLists.txt
--- /work/lua-5.1.5/CMakeLists.txt	1969-12-31 16:00:00.000000000 -0800
+++ lua-5_1_5/CMakeLists.txt	2015-01-16 10:26:29.623543211 -0800
@@ -0,0 +1,64 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+cmake_minimum_required(VERSION 2.8 FATAL_ERROR)
+project(lua C)
+
+set(LUA_SOURCE
+src/lapi.c
+src/lauxlib.c
+src/lbaselib.c
+src/lcode.c
+src/ldblib.c
+src/ldebug.c
+src/ldo.c
+src/ldump.c
+src/lfunc.c
+src/lgc.c
+src/linit.c
+src/liolib.c
+src/llex.c
+src/lmathlib.c
+src/lmem.c
+src/loadlib.c
+src/lobject.c
+src/lopcodes.c
+src/loslib.c
+src/lparser.c
+src/lstate.c
+src/lstring.c
+src/lstrlib.c
+src/ltable.c
+src/ltablib.c
+src/ltm.c
+src/lundump.c
+src/lvm.c
+src/lzio.c
+)
+
+set(CMAKE_INSTALL_PREFIX ${EP_BASE})
+if (WIN32)
+    add_library(lua SHARED ${LUA_SOURCE})
+    add_definitions(-DLUA_WIN)
+    add_definitions(-DLUA_BUILD_AS_DLL)
+    if (MINGW)
+        set_target_properties(lua PROPERTIES LINK_FLAGS -s)
+        if (ADDRESS_MODEL EQUAL 32)
+            set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -m32")
+            set_target_properties(lua PROPERTIES LINK_FLAGS "-s -m32")
+        endif()
+    endif()
+elseif(APPLE)
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fPIC")
+    add_library(lua STATIC ${LUA_SOURCE})
+    add_definitions(-DLUA_USE_MACOSX)
+    target_link_libraries(lua -lreadline)
+else()
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fPIC")
+    add_library(lua STATIC ${LUA_SOURCE})
+    add_definitions(-DLUA_USE_LINUX)
+endif()
+
+install(TARGETS lua DESTINATION lib)
+install(FILES src/lua.h src/luaconf.h src/lualib.h src/lauxlib.h DESTINATION include)
diff -Naur /work/lua-5.1.5/src/ldebug.c lua-5_1_5/src/ldebug.c
--- /work/lua-5.1.5/src/ldebug.c	2008-05-08 09:56:26.000000000 -0700
+++ lua-5_1_5/src/ldebug.c	2015-01-16 10:26:29.623543211 -0800
@@ -80,6 +80,10 @@
   return L->basehookcount;
 }
 
+LUA_API int lua_gethookcountremaining (lua_State *L) {
+  return L->hookcount;
+}
+
 
 LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
   int status;
diff -Naur /work/lua-5.1.5/src/loadlib.c lua-5_1_5/src/loadlib.c
--- /work/lua-5.1.5/src/loadlib.c	2009-09-09 06:17:16.000000000 -0700
+++ lua-5_1_5/src/loadlib.c	2015-01-21 06:37:34.841228660 -0800
@@ -23,23 +23,22 @@
 
 
 /* prefix for open functions in C libraries */
-#define LUA_POF		"luaopen_"
+#define LUA_POF   "luaopen_"
 
 /* separator for open functions in C libraries */
-#define LUA_OFSEP	"_"
+#define LUA_OFSEP "_"
 
 
-#define LIBPREFIX	"LOADLIB: "
+#define LIBPREFIX "LOADLIB: "
 
-#define POF		LUA_POF
-#define LIB_FAIL	"open"
+#define POF   LUA_POF
+#define LIB_FAIL  "open"
 
 
 /* error codes for ll_loadfunc */
-#define ERRLIB		1
-#define ERRFUNC		2
+#define ERRLIB    1
+#define ERRFUNC   2
 
-#define setprogdir(L)		((void)0)
 
 
 static void ll_unloadlib (void *lib);
@@ -91,24 +90,6 @@
 
 #include <windows.h>
 
-
-#undef setprogdir
-
-static void setprogdir (lua_State *L) {
-  char buff[MAX_PATH + 1];
-  char *lb;
-  DWORD nsize = sizeof(buff)/sizeof(char);
-  DWORD n = GetModuleFileNameA(NULL, buff, nsize);
-  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\')) == NULL)
-    luaL_error(L, "unable to get ModuleFileName");
-  else {
-    *lb = '\0';
-    luaL_gsub(L, lua_tostring(L, -1), LUA_EXECDIR, buff);
-    lua_remove(L, -2);  /* remove original string */
-  }
-}
-
-
 static void pusherror (lua_State *L) {
   int error = GetLastError();
   char buffer[128];
@@ -153,7 +134,7 @@
 
 /* Mac appends a `_' before C function names */
 #undef POF
-#define POF	"_" LUA_POF
+#define POF "_" LUA_POF
 
 
 static void pusherror (lua_State *L) {
@@ -230,10 +211,10 @@
 */
 
 #undef LIB_FAIL
-#define LIB_FAIL	"absent"
+#define LIB_FAIL  "absent"
 
 
-#define DLMSG	"dynamic libraries not enabled; check your Lua installation"
+#define DLMSG "dynamic libraries not enabled; check your Lua installation"
 
 
 static void ll_unloadlib (void *lib) {
@@ -351,11 +332,20 @@
 static const char *findfile (lua_State *L, const char *name,
                                            const char *pname) {
   const char *path;
-  name = luaL_gsub(L, name, ".", LUA_DIRSEP);
-  lua_getfield(L, LUA_ENVIRONINDEX, pname);
+  int i = 0;
+  while (name[i]) {
+    if (!isalnum(name[i]) && name[i] != '_') {
+      luaL_error(L, "invalid module name '%s'", name);
+      return NULL; // never reached, just silences the compiler
+    }
+    ++i;
+  }
+  lua_pushstring(L, name);
+  lua_getfield(L, LUA_REGISTRYINDEX, pname);
   path = lua_tostring(L, -1);
-  if (path == NULL)
-    luaL_error(L, LUA_QL("package.%s") " must be a string", pname);
+  if (path == NULL) {
+    return NULL;
+  }
   lua_pushliteral(L, "");  /* error accumulator */
   while ((path = pushnexttemplate(L, path)) != NULL) {
     const char *filename;
@@ -380,7 +370,7 @@
 static int loader_Lua (lua_State *L) {
   const char *filename;
   const char *name = luaL_checkstring(L, 1);
-  filename = findfile(L, name, "path");
+  filename = findfile(L, name, "lsb_require_path");
   if (filename == NULL) return 1;  /* library not found in this path */
   if (luaL_loadfile(L, filename) != 0)
     loaderror(L, filename);
@@ -402,7 +392,7 @@
 static int loader_C (lua_State *L) {
   const char *funcname;
   const char *name = luaL_checkstring(L, 1);
-  const char *filename = findfile(L, name, "cpath");
+  const char *filename = findfile(L, name, "lsb_require_cpath");
   if (filename == NULL) return 1;  /* library not found in this path */
   funcname = mkfuncname(L, name);
   if (ll_loadfunc(L, filename, funcname) != 0)
@@ -411,41 +401,29 @@
 }
 
 
-static int loader_Croot (lua_State *L) {
-  const char *funcname;
-  const char *filename;
-  const char *name = luaL_checkstring(L, 1);
-  const char *p = strchr(name, '.');
-  int stat;
-  if (p == NULL) return 0;  /* is root */
-  lua_pushlstring(L, name, p - name);
-  filename = findfile(L, lua_tostring(L, -1), "cpath");
-  if (filename == NULL) return 1;  /* root not found */
-  funcname = mkfuncname(L, name);
-  if ((stat = ll_loadfunc(L, filename, funcname)) != 0) {
-    if (stat != ERRFUNC) loaderror(L, filename);  /* real error */
-    lua_pushfstring(L, "\n\tno module " LUA_QS " in file " LUA_QS,
-                       name, filename);
-    return 1;  /* function not found */
-  }
-  return 1;
-}
-
-
 static int loader_preload (lua_State *L) {
   const char *name = luaL_checkstring(L, 1);
   lua_getfield(L, LUA_ENVIRONINDEX, "preload");
   if (!lua_istable(L, -1))
-    luaL_error(L, LUA_QL("package.preload") " must be a table");
+    luaL_error(L, LUA_QL("preload") " must be a table");
   lua_getfield(L, -1, name);
-  if (lua_isnil(L, -1))  /* not found? */
-    lua_pushfstring(L, "\n\tno field package.preload['%s']", name);
   return 1;
 }
 
+// If necessary, add an empty metatable to flag the table as non-data
+// during preservation.
+static void add_empty_metatable(lua_State* lua)
+{
+  if (lua_getmetatable(lua, -1) == 0) {
+    lua_newtable(lua);
+    lua_setmetatable(lua, -2);
+  } else {
+    lua_pop(lua, 1);
+  }
+}
 
 static const int sentinel_ = 0;
-#define sentinel	((void *)&sentinel_)
+#define sentinel  ((void *)&sentinel_)
 
 
 static int ll_require (lua_State *L) {
@@ -462,7 +440,7 @@
   /* else must load it; iterate over available loaders */
   lua_getfield(L, LUA_ENVIRONINDEX, "loaders");
   if (!lua_istable(L, -1))
-    luaL_error(L, LUA_QL("package.loaders") " must be a table");
+    luaL_error(L, LUA_QL("loaders") " must be a table");
   lua_pushliteral(L, "");  /* error message accumulator */
   for (i=1; ; i++) {
     lua_rawgeti(L, -2, i);  /* get a loader */
@@ -490,138 +468,27 @@
     lua_pushvalue(L, -1);  /* extra copy to be returned */
     lua_setfield(L, 2, name);  /* _LOADED[name] = true */
   }
+  add_empty_metatable(L);
+  /* todo  apply restrictions */
   return 1;
 }
 
 /* }====================================================== */
 
 
-
-/*
-** {======================================================
-** 'module' function
-** =======================================================
-*/
-  
-
-static void setfenv (lua_State *L) {
-  lua_Debug ar;
-  if (lua_getstack(L, 1, &ar) == 0 ||
-      lua_getinfo(L, "f", &ar) == 0 ||  /* get calling function */
-      lua_iscfunction(L, -1))
-    luaL_error(L, LUA_QL("module") " not called from a Lua function");
-  lua_pushvalue(L, -2);
-  lua_setfenv(L, -2);
-  lua_pop(L, 1);
-}
-
-
-static void dooptions (lua_State *L, int n) {
-  int i;
-  for (i = 2; i <= n; i++) {
-    lua_pushvalue(L, i);  /* get option (a function) */
-    lua_pushvalue(L, -2);  /* module */
-    lua_call(L, 1, 0);
-  }
-}
-
-
-static void modinit (lua_State *L, const char *modname) {
-  const char *dot;
-  lua_pushvalue(L, -1);
-  lua_setfield(L, -2, "_M");  /* module._M = module */
-  lua_pushstring(L, modname);
-  lua_setfield(L, -2, "_NAME");
-  dot = strrchr(modname, '.');  /* look for last dot in module name */
-  if (dot == NULL) dot = modname;
-  else dot++;
-  /* set _PACKAGE as package name (full module name minus last part) */
-  lua_pushlstring(L, modname, dot - modname);
-  lua_setfield(L, -2, "_PACKAGE");
-}
-
-
-static int ll_module (lua_State *L) {
-  const char *modname = luaL_checkstring(L, 1);
-  int loaded = lua_gettop(L) + 1;  /* index of _LOADED table */
-  lua_getfield(L, LUA_REGISTRYINDEX, "_LOADED");
-  lua_getfield(L, loaded, modname);  /* get _LOADED[modname] */
-  if (!lua_istable(L, -1)) {  /* not found? */
-    lua_pop(L, 1);  /* remove previous result */
-    /* try global variable (and create one if it does not exist) */
-    if (luaL_findtable(L, LUA_GLOBALSINDEX, modname, 1) != NULL)
-      return luaL_error(L, "name conflict for module " LUA_QS, modname);
-    lua_pushvalue(L, -1);
-    lua_setfield(L, loaded, modname);  /* _LOADED[modname] = new table */
-  }
-  /* check whether table already has a _NAME field */
-  lua_getfield(L, -1, "_NAME");
-  if (!lua_isnil(L, -1))  /* is table an initialized module? */
-    lua_pop(L, 1);
-  else {  /* no; initialize it */
-    lua_pop(L, 1);
-    modinit(L, modname);
-  }
-  lua_pushvalue(L, -1);
-  setfenv(L);
-  dooptions(L, loaded - 1);
-  return 0;
-}
-
-
-static int ll_seeall (lua_State *L) {
-  luaL_checktype(L, 1, LUA_TTABLE);
-  if (!lua_getmetatable(L, 1)) {
-    lua_createtable(L, 0, 1); /* create new metatable */
-    lua_pushvalue(L, -1);
-    lua_setmetatable(L, 1);
-  }
-  lua_pushvalue(L, LUA_GLOBALSINDEX);
-  lua_setfield(L, -2, "__index");  /* mt.__index = _G */
-  return 0;
-}
-
-
-/* }====================================================== */
-
-
-
-/* auxiliary mark (for internal use) */
-#define AUXMARK		"\1"
-
-static void setpath (lua_State *L, const char *fieldname, const char *envname,
-                                   const char *def) {
-  const char *path = getenv(envname);
-  if (path == NULL)  /* no environment variable? */
-    lua_pushstring(L, def);  /* use default */
-  else {
-    /* replace ";;" by ";AUXMARK;" and then AUXMARK by default path */
-    path = luaL_gsub(L, path, LUA_PATHSEP LUA_PATHSEP,
-                              LUA_PATHSEP AUXMARK LUA_PATHSEP);
-    luaL_gsub(L, path, AUXMARK, def);
-    lua_remove(L, -2);
-  }
-  setprogdir(L);
-  lua_setfield(L, -2, fieldname);
-}
-
-
 static const luaL_Reg pk_funcs[] = {
-  {"loadlib", ll_loadlib},
-  {"seeall", ll_seeall},
   {NULL, NULL}
 };
 
 
 static const luaL_Reg ll_funcs[] = {
-  {"module", ll_module},
   {"require", ll_require},
   {NULL, NULL}
 };
 
 
 static const lua_CFunction loaders[] =
-  {loader_preload, loader_Lua, loader_C, loader_Croot, NULL};
+  {loader_preload, loader_Lua, loader_C, NULL};
 
 
 LUALIB_API int luaopen_package (lua_State *L) {
@@ -630,12 +497,8 @@
   luaL_newmetatable(L, "_LOADLIB");
   lua_pushcfunction(L, gctm);
   lua_setfield(L, -2, "__gc");
-  /* create `package' table */
-  luaL_register(L, LUA_LOADLIBNAME, pk_funcs);
-#if defined(LUA_COMPAT_LOADLIB) 
-  lua_getfield(L, -1, "loadlib");
-  lua_setfield(L, LUA_GLOBALSINDEX, "loadlib");
-#endif
+  /* create `package' environment table (not exposed to Lua) */
+  lua_newtable(L);
   lua_pushvalue(L, -1);
   lua_replace(L, LUA_ENVIRONINDEX);
   /* create `loaders' table */
@@ -646,21 +509,17 @@
     lua_rawseti(L, -2, i+1);
   }
   lua_setfield(L, -2, "loaders");  /* put it in field `loaders' */
-  setpath(L, "path", LUA_PATH, LUA_PATH_DEFAULT);  /* set field `path' */
-  setpath(L, "cpath", LUA_CPATH, LUA_CPATH_DEFAULT); /* set field `cpath' */
-  /* store config information */
-  lua_pushliteral(L, LUA_DIRSEP "\n" LUA_PATHSEP "\n" LUA_PATH_MARK "\n"
-                     LUA_EXECDIR "\n" LUA_IGMARK);
-  lua_setfield(L, -2, "config");
-  /* set field `loaded' */
-  luaL_findtable(L, LUA_REGISTRYINDEX, "_LOADED", 2);
-  lua_setfield(L, -2, "loaded");
+
   /* set field `preload' */
-  lua_newtable(L);
+  luaL_findtable(L, LUA_REGISTRYINDEX, "_PRELOADED", 0);
   lua_setfield(L, -2, "preload");
+
+  /* open lib into global table */
   lua_pushvalue(L, LUA_GLOBALSINDEX);
-  luaL_register(L, NULL, ll_funcs);  /* open lib into global table */
+  luaL_register(L, NULL, ll_funcs);
   lua_pop(L, 1);
+
+  /* create an empty `package' table */
+  luaL_register(L, LUA_LOADLIBNAME, pk_funcs);
   return 1;  /* return 'package' table */
 }
-
diff -Naur /work/lua-5.1.5/src/loslib.c lua-5_1_5/src/loslib.c
--- /work/lua-5.1.5/src/loslib.c	2008-01-18 08:38:18.000000000 -0800
+++ lua-5_1_5/src/loslib.c	2015-01-16 10:26:29.623543211 -0800
@@ -33,6 +33,61 @@
     return 3;
   }
 }
+/*
+** list of valid conversion specifiers for the 'strftime' function
+*/
+#if !defined(LUA_STRFTIMEOPTIONS)
+
+#if !defined(LUA_USE_POSIX)
+#define LUA_STRFTIMEOPTIONS	{ "aAbBcdHIjmMpSUwWxXyYzZ%", "" }
+#else
+#define LUA_STRFTIMEOPTIONS \
+	{ "aAbBcCdDeFgGhHIjklmMnprRSstTuUVwWxXyYzZ%", "" \
+	  "", "E", "cCxXyY",  \
+	  "O", "deHImMSuUVwWy" }
+#endif
+
+#endif
+
+
+
+/*
+** By default, Lua uses tmpnam except when POSIX is available, where it
+** uses mkstemp.
+*/
+#if defined(LUA_USE_MKSTEMP)
+#include <unistd.h>
+#define LUA_TMPNAMBUFSIZE	32
+#define lua_tmpnam(b,e) { \
+        strcpy(b, "/tmp/lua_XXXXXX"); \
+        e = mkstemp(b); \
+        if (e != -1) close(e); \
+        e = (e == -1); }
+
+#elif !defined(lua_tmpnam)
+
+#define LUA_TMPNAMBUFSIZE	L_tmpnam
+#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
+
+#endif
+
+
+/*
+** By default, Lua uses gmtime/localtime, except when POSIX is available,
+** where it uses gmtime_r/localtime_r
+*/
+#if defined(LUA_USE_GMTIME_R)
+
+#define l_gmtime(t,r)		gmtime_r(t,r)
+#define l_localtime(t,r)	localtime_r(t,r)
+
+#elif !defined(l_gmtime)
+
+#define l_gmtime(t,r)		((void)r, gmtime(t))
+#define l_localtime(t,r)  	((void)r, localtime(t))
+
+#endif
+
 
 
 static int os_execute (lua_State *L) {
@@ -121,16 +176,40 @@
 }
 
 
+static const char *checkoption (lua_State *L, const char *conv, char *buff) {
+  static const char *const options[] = LUA_STRFTIMEOPTIONS;
+  unsigned int i;
+  for (i = 0; i < sizeof(options)/sizeof(options[0]); i += 2) {
+    if (*conv != '\0' && strchr(options[i], *conv) != NULL) {
+      buff[1] = *conv;
+      if (*options[i + 1] == '\0') {  /* one-char conversion specifier? */
+        buff[2] = '\0';  /* end buffer */
+        return conv + 1;
+      }
+      else if (*(conv + 1) != '\0' &&
+               strchr(options[i + 1], *(conv + 1)) != NULL) {
+        buff[2] = *(conv + 1);  /* valid two-char conversion specifier */
+        buff[3] = '\0';  /* end buffer */
+        return conv + 2;
+      }
+    }
+  }
+  luaL_argerror(L, 1,
+    lua_pushfstring(L, "invalid conversion specifier '%%%s'", conv));
+  return conv;  /* to avoid warnings */
+}
+
+
 static int os_date (lua_State *L) {
   const char *s = luaL_optstring(L, 1, "%c");
   time_t t = luaL_opt(L, (time_t)luaL_checknumber, 2, time(NULL));
-  struct tm *stm;
+  struct tm tmr, *stm;
   if (*s == '!') {  /* UTC? */
-    stm = gmtime(&t);
+    stm = l_gmtime(&t, &tmr);
     s++;  /* skip `!' */
   }
   else
-    stm = localtime(&t);
+    stm = l_localtime(&t, &tmr);
   if (stm == NULL)  /* invalid date? */
     lua_pushnil(L);
   else if (strcmp(s, "*t") == 0) {
@@ -146,17 +225,17 @@
     setboolfield(L, "isdst", stm->tm_isdst);
   }
   else {
-    char cc[3];
+    char cc[4];
     luaL_Buffer b;
-    cc[0] = '%'; cc[2] = '\0';
+    cc[0] = '%';
     luaL_buffinit(L, &b);
-    for (; *s; s++) {
-      if (*s != '%' || *(s + 1) == '\0')  /* no conversion specifier? */
-        luaL_addchar(&b, *s);
+    while (*s) {
+      if (*s != '%')  /* no conversion specifier? */
+        luaL_addchar(&b, *s++);
       else {
         size_t reslen;
         char buff[200];  /* should be big enough for any conversion result */
-        cc[1] = *(++s);
+        s = checkoption(L, s + 1, cc);
         reslen = strftime(buff, sizeof(buff), cc, stm);
         luaL_addlstring(&b, buff, reslen);
       }
diff -Naur /work/lua-5.1.5/src/luaconf.h lua-5_1_5/src/luaconf.h
--- /work/lua-5.1.5/src/luaconf.h	2008-02-11 08:25:08.000000000 -0800
+++ lua-5_1_5/src/luaconf.h	2015-01-16 10:26:29.623543211 -0800
@@ -1,5 +1,5 @@
 /*
-** $Id: luaconf.h,v 1.82.1.7 2008/02/11 16:25:08 roberto Exp $
+** $Id: luaconf.h,v 1.176.1.1 2013/04/12 18:48:47 roberto Exp $
 ** Configuration file for Lua
 ** See Copyright Notice in lua.h
 */
@@ -33,14 +33,26 @@
 #define LUA_WIN
 #endif
 
+#if defined(LUA_WIN)
+#define LUA_DL_DLL
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#endif
+
 #if defined(LUA_USE_LINUX)
 #define LUA_USE_POSIX
 #define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
 #define LUA_USE_READLINE	/* needs some extra libraries */
+#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hex formats */
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#define LUA_USE_LONGLONG	/* assume support for long long */
 #endif
 
 #if defined(LUA_USE_MACOSX)
 #define LUA_USE_POSIX
+#define LUA_USE_DLOPEN		/* does not need -ldl */
+#define LUA_USE_READLINE	/* needs an extra library: -lreadline */
+#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hex formats */
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
 #define LUA_DL_DYLD		/* does not need extra library */
 #endif
 
@@ -56,6 +68,7 @@
 #define LUA_USE_ISATTY
 #define LUA_USE_POPEN
 #define LUA_USE_ULONGJMP
+#define LUA_USE_GMTIME_R
 #endif
 
 
diff -Naur /work/lua-5.1.5/src/lua.h lua-5_1_5/src/lua.h
--- /work/lua-5.1.5/src/lua.h	2012-01-13 12:36:20.000000000 -0800
+++ lua-5_1_5/src/lua.h	2015-01-16 10:26:29.623543211 -0800
@@ -341,6 +341,7 @@
 LUA_API lua_Hook lua_gethook (lua_State *L);
 LUA_API int lua_gethookmask (lua_State *L);
 LUA_API int lua_gethookcount (lua_State *L);
+LUA_API int lua_gethookcountremaining (lua_State *L);
 
 
 struct lua_Debug {
